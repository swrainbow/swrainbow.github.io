---
title: 渲染流水线
date: 2023-07-06 18:19:04
tags:
---
# 整体流程
渲染管线定义：3D元素数据--渲染管线-->屏幕上2D图像
工作流程线性，上一个阶段的输出变为下一个阶段的输入

应用阶段：粗粒度剔除，进行渲染设置，准备基本数据，输出到几何阶段

几何阶段：顶点着色器，曲面细分，几何着色器，顶点裁剪，屏幕映射

光栅化阶段：三角形（点/线）设置，三角形（点/线）遍历，片段着色器

逐片元操作：裁剪测试，透明度测试，深度测试，模板测试，混合

后处理
![](https://strainbow.oss-cn-hangzhou.aliyuncs.com/20230706191615.png)

# 应用阶段
- 准备基本场景数据 
  - 场景物体数据 
    - 物体变换数据：位置、旋转、缩放等
    - 物体网格数据：顶点位置、UV贴图等
  - 摄像机数据 
    - 位置、方向
    - 远近裁剪平面
    - 正交/透视
    - 视口比例/尺寸
  - 光源及阴影数据 
    - 设置光源 
      - 方向光：颜色、方向等
      - 点光：颜色、位置、方向等
      - 聚光灯：颜色、位置、方向、内外圆锥角等
    - 设置阴影 
      - 是否需要阴影：判断该光源可见范围是否有可投射阴影的物体
      - 阴影参数：对应光源序号、阴影强度、级联参数、深度偏移、近平面偏移等
    - 逐光源绘制阴影贴图 
      - 近平面偏移
      - 逐级联 
        - 计算当前光源+级联对应的管擦和矩阵、投影矩阵、以及对应到阴影贴图里的视口区域
        - 绘制到阴影贴图
  - 其他全局数据
- 加速算法 粗粒度剔除 
  - 碰撞检测
  - 加速算法
  - 遮挡剔除
  - 可见光裁剪
  - 可见场景物体裁剪 
    - 八叉树
    - BSP树
    - K-D树
    - BVH
  - 其他算法
- 设置渲染状态 准备渲染参数 
  - 绘制设置 
    - 合批方式
  - 绘制顺序 
    - 相对摄像机的距离
    - 材质RenderQueue
    - UICanvas
    - 其他方式等
  - 渲染目标 
    - FrameBuffer
    - RenderTexture
  - 渲染模式 
    - 前向渲染
    - 延迟渲染
- 调用DrawCall 输出渲染图元到显存 
  - 顶点数据 
    - 位置
    - 颜色
    - 法线
    - 纹理uv坐标
    - 其他顶点数据
  - 其他数据 
    - MVP变换矩阵
    - 纹理贴图
    - 其他数据


# 几何阶段
- 顶点着色 
  - 视图变换
  ![](https://strainbow.oss-cn-hangzhou.aliyuncs.com/20230706192019.png)
    - 顶点着色
- 可选顶点处理 
  - 曲面细分(可选)
  ![](https://strainbow.oss-cn-hangzhou.aliyuncs.com/20230706192046.png)
  -几何着色器(可选)
- 投影 
  - 正交
  - 透视
- 裁剪 
  - 视锥体裁剪(CVV)
    - NDC差异 
        - OpenGL：$x,y,z\in [-1,1]$
        - D3D：$x,y\in [-1,1]$ $z\in [0,1]$
  - 正面或背面剔除(可配置)
  - 屏幕映射 
    - 从连续到离散
    - 坐标系差异(OpenGL/D3D) 
        - OpenGL：左下方
        - D3D：左上方

# 光栅化阶段
- 三角形设置 
  - 计算三角形网格信息，计算例如顶点坐标和edge函数
- 三角形遍历 
  - 检查每个像素是否在三角形内部，如果在，则生成一系列插值数据序列
- 抗锯齿(MSAA) 
  - 光栅化阶段
  - 计算多个覆盖样本

## 逐片元操作
- 片元着色 
    ![](https://strainbow.oss-cn-hangzhou.aliyuncs.com/20230706192447.png)
- 颜色混合 
  - Alpha Test
  - Stencil Test
  - DepthBuffer Test
  - Blending
- 目标缓冲区 
  - FrameBuffer
  - RenderTexture

# DrawCall
DrawCall是指在应用阶段生成的渲染命令，用于绘制一个或多个图元(如三角形)的请求。每个DrawCall包含了一组渲染状态(如渲染目标、着色器程序、纹理等)和要渲染的几何数据。
DrawCall在应用阶段生成。在应用阶段，应用程序通过调用图形API发送渲染命令给图形硬件。这些渲染命令包括绘制调用，即DrawCall。

具体来说，DrawCall在渲染管线的不同阶段起着不同的作用：
- 应用阶段：应用程序将准备好的几何数据(如顶点坐标、纹理坐标等)和渲染状态(如光照、材质属性等)通过DrawCall发送给图形硬件。应用阶段的DrawCall将几何数据传递到下一个阶段，即几何阶段。
- 几何阶段：在几何阶段，图形硬件对传入的几何数据进行处理，执行顶点着色器、图元装配和裁剪等操作。每个DrawCall会经过几何阶段的处理，生成裁剪后的几何图元。
- 光栅化阶段：在光栅化阶段，裁剪后的几何图元被转换为屏幕上的像素。这个阶段包括三角形光栅化、像素插值和面剔除等操作。每个DrawCall生成的几何图元会经过光栅化阶段的处理，生成覆盖屏幕上像素的片段。
- 像素阶段：像素阶段是渲染管线的最后一个阶段。在像素阶段，对每个片段进行像素着色器的计算，确定最终像素的颜色、深度和其他属性。每个DrawCall生成的片段会经过像素阶段的处理，最终输出到帧缓冲中。

DrawCall与性能息息相关。例如一个场景中有两个小人，如果在应用阶段分别导入，那么就会产生两次DrawCall。如果将它们合并(Batch)，则只会产生一次Drawcall。
DrawCall批次太多会导致CPU性能开销过大，一般来说有两种解决方法：
- 合批，把模型合成一个大mesh。
- GPU Instance，用于绘制重复的模型。只需要提交一次模型数据，通过在GPU中对buffer进行偏移获取本次绘制的计算数据。

# 总结
![](https://strainbow.oss-cn-hangzhou.aliyuncs.com/20230708192233.png)

